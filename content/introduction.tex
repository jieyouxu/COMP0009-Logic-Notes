\chapter{Introduction}

\section{Formal Logic}

Formal logic consists of three parts:

\begin{enumerate}
    \item \Keyword{Syntax}: the grammar of the logic language.
    \item \Keyword{Semantics}: how the language is to be interpreted.
    \item \Keyword{Inference} or \Keyword{Proof System}: how true statements are
        to be proved through reasoning.
\end{enumerate}

\section{Propositional Logic}

\subsection{Grammar}

The grammar for \Keyword{Propositional logic} is given by Figure 
\ref{fig:propositional_logic_bnf}.

\begin{figure}[H]
    \centering
    \begin{grammar}
    <formula> ::= \lit{$($} <formula> <binary-op> <formula> \lit{$)$}
        \alt \lit{$\neg$} <formula>
        \alt <proposition>
    
    <binary-op> ::= \lit{$\land$} | \lit{$\lor$} | \lit{$\to$} | \lit{$\Iff$}
    
    <proposition> ::= \lit{$p$} | \lit{$q$} | \lit{$r$} | $\cdots$
    \end{grammar}
    \caption{BNF Grammar for Propositional Logic.}
    \label{fig:propositional_logic_bnf}
\end{figure}

Each $\Angled{\textit{proposition}}$ is a variable from a set of
\Keyword{variables} $\mathcal{V}$ that is assumed to be infinite. That is, 
$p, q, r \in \mathcal{V}$.

The \textit{binary operators} ($\Angled{\textit{binary-op}}$) $\land$, $\lor$ 
and $\to$ are also called \Keyword{connectives}.

\begin{definition}[Literal]
    A \Keyword{literal} is either a \textit{proposition} or 
    its \textit{negation}.
\end{definition}

\begin{example}[Literal]
    $p$ and $\neg q$ are both literals but $(p \land q)$ is not.
\end{example}

\begin{definition}[Main Connective].
    The \Keyword{main connective} of a propositional formula $\phi$ is defined 
    to be the connective with the \textit{largest scope}.
\end{definition}

\begin{example}[Main Connective]
    Let
    \begin{equation*}
        \phi \DefAs ((p \land q) \lor (q \to r))
    \end{equation*}
    
    Then $\lor$ is the \textit{main connective} since it has the largest scope.
\end{example}

\subsection{Semantics}

To interpret propositional formulas, we need \Keyword{valuations} to map 
propositions to $\Set{ \top, \bot }$ (\textit{true} or \textit{false}, 
respectively).

\begin{definition}[Valuation]
    A \Keyword{valuation} $v$ maps any proposition $p \in \mathcal{V}$ 
    to $\Set{ \top, \bot }$
    
    \begin{equation}
        v \colon \mathcal{V} \to \Set{ \top, \bot }
    \end{equation}
    
    $v$ satisfies the properties:
    
    \begin{align}
        v(\neg \phi) = \top &\WIff v(\phi) = \bot \\
        v(\phi \land \psi) = \top &\WIff v(\phi) = v(\psi) = \top \\
        v(\phi \lor \psi) = \top 
            &\WIff v(\phi) = \top \Stext{or} v(\psi) = \top \\
        v(\phi \to \psi) = \top 
            &\WIff = v(\phi) = \bot \Stext{or} v(\psi) = \top
    \end{align}
\end{definition}

\subsection{Validity, Satisfiability, Equivalence}

\begin{definition}[Valid]
    A formula $\phi$ is \Keyword{valid} iff
    
    \begin{equation}
        \Forall v \in \text{Valuations} \colon v(\phi) = \top
    \end{equation}
    
    That is, $\phi$ must evaluate to true when interpreted by \textit{any} 
    valuation $v \colon \mathcal{V} \to \Set{\top, \bot}$.
\end{definition}

\begin{definition}[Satisfiable]
    A formula $\phi$ is \Keyword{satisfiable} iff
    
    \begin{equation}
        \Exists v \in \text{Valuations} \colon v(\phi) = \top
    \end{equation}
    
    That is, $\phi$ must evaluate to true for \textit{at least one} valuation 
    $v$.
\end{definition}

\begin{definition}[Equivalent]
    The formulas $\phi$ and $\psi$ are \Keyword{logically equivalent}, denoted 
    $\phi \equiv \psi$, iff
    
    \begin{equation}
        \Forall v \in \text{Valuations} \colon v(\phi) = v(\psi)
    \end{equation}
\end{definition}

\begin{remark}
    Every \textit{valid} formula is \textit{satisfiable}, but not the converse:
    
    \begin{itemize}
        \item Validity $\to$ Satisfiability.
        \item Satisfiability $\not\to$ Validity.
    \end{itemize}
\end{remark}

\section{First-Order Logic (Predicate Logic)}

\subsection{Syntax}

\begin{definition}[First-Order Logic]
    A \Keyword{first-order logic} language $L$ is a 3-tuple

    \begin{equation}
        L \DefAs \Angled{\mathcal{C}, \mathcal{F}, \mathcal{P}}
    \end{equation}

    Where:

    \begin{enumerate}
        \item $\mathcal{C}$ is the set of \Keyword{constant symbols}.
        \item $\mathcal{F}$ is the set of \Keyword{function symbols}.
            Let $f^n$ denote function $f$ is of \Keyword{arity} $n$.
        \item $\mathcal{P}$ is the non-empty set of \Keyword{predicate symbols}.
            Let $p^n$ denote predicate $p$ is of \Keyword{arity} $n$.
    \end{enumerate}
    
    And let $\mathcal{V}$ be the infinite set of \textit{variable symbols}.
\end{definition}

The grammar of first-order logic is given in Figure \ref{fig:first_order_logic_bnf}.

\begin{figure}[H]
    \centering
    \begin{grammar}
    <formula> ::= \lit{$($} <formula>$_0$ <binary-op> <formula>$_1$ \lit{$)$}
        \alt \lit{$\Forall$} $v$ \lit{$\colon$} <formula>
            \quad\text{// where $v \in \mathcal{V}$}
        \alt \lit{$\Exists$} $v$ \lit{$\colon$} <formula>
            \quad\text{// where $v \in \mathcal{V}$}
        \alt \lit{$\neg$} <formula>
        \alt <atom>
    
    <binary-op> ::= \lit{$\land$} | \lit{$\lor$} | \lit{$\to$} | \lit{$\Iff$}
    
    <atom> ::= $p^n$ \lit{$($} <term>$_0$ \lit{,} <term>$_1$ \lit{,} 
        $\ldots$ \lit{,} <term>$_{n-1}$ \lit{$)$} \quad\text{// where $p^n \in \mathcal{P}$}
    
    <term> ::= $f^n$ \lit{$($} <term>$_0$ \lit{,} <term>$_1$ \lit{,} 
            $\ldots$ \lit{,} <term>$_{n-1}$ \lit{$)$} \quad\text{// where $f^n \in \mathcal{F}$}
        \alt $c$ \quad\text{// where $c \in \mathcal{C}$}
        \alt $v$ \quad\text{// where $v \in \mathcal{V}$}
    \end{grammar}
    \caption{BNF Grammar for First-Order Logic.}
    \label{fig:first_order_logic_bnf}
\end{figure}

\begin{definition}[Arity]
    The \Keyword{arity} of a \textit{predicate symbol} or a \textit{function symbol} is the
    \textit{number of arguments} that the predicate or function symbol takes.
    
    \textit{Constant symbols} are of arity $0$ since they do not take arguments.
\end{definition}

\begin{definition}[Predicate Formula]
    There are two types of \textit{predicate formula}, as specified in the BNF of Figure 
    \ref{fig:first_order_logic_bnf}:
    
    \begin{enumerate}
        \item \Keyword{Atomic} formula, of the form
            \begin{equation}
                R(\tau_0, \ldots, \tau_{n-1})
            \end{equation}
            
            Where
            \begin{itemize}
                \item $\tau_{i}$ is some \textit{term} given $i < n$; and
                \item $R \in \mathcal{P}$ is a \textit{predicate} of arity $n$.
            \end{itemize}
        \item \Keyword{Formula}, of the form
            \begin{equation}
                \phi \Coloneqq \mathrm{Atom} 
                    \mid \neg \phi 
                    \mid ( \phi \neg \phi' )
                    \mid \Exists x \colon \phi
            \end{equation}
            
            And we can define $\Forall x \colon \phi \equiv \neg \Exists x \colon \neg \phi$.
    \end{enumerate}
\end{definition}

\subsection{Semantics}

\begin{definition}[$L$-Structure]
    A \Keyword{first-order structure} or a \Keyword{$L$-structure} is a 2-tuple
    
    \begin{equation}
        L\text{-structure} \DefAs \Angled{D, I}
    \end{equation}
    
    Where
    \begin{enumerate}
        \item $D$ is the \Keyword{domain}, a non-empty set; and
        \item $I$ is the valuation function which interprets \textit{constants}, \textit{functions}
            and \textit{predicates}.
    \end{enumerate}
\end{definition}

\begin{definition}[Interpretation Function (Valuation)]
    The type of the \Keyword{interpretation function} or \Keyword{valuation} $I$ which interprets
    \textit{constants}, \textit{functions} and \textit{predicates} is given as
    
    \begin{align}
        I    \colon &\ \mathcal{C} \to D \\
        I(f) \colon &\ D^n \to D \quad\text{(iff $f \in \mathcal{F}$ is a $n$-ary function)} \\
        I(R) \subseteq &\ D^n \quad\text{(iff $p \in \mathcal{R}$ is a $n$-ary predicate)}    
    \end{align}
\end{definition}
